#region License
/*
 * Copyright (c) 2023 Stefano Moioli
 * This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 *  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 *  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 *  3. This notice may not be removed or altered from any source distribution.
 */
#endregion
ï»¿using Org.BouncyCastle.Utilities.Encoders;
using Yafex.Support;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Yafex.FileFormats.Lzhs
{
	public unsafe struct LzhsHeader {
		public uint uncompressedSize;
		public uint compressedSize;
		public ushort checksum;
		public fixed byte spare[6];
		
		public static int SIZE => sizeof(LzhsHeader);

		public LzhsHeader(ReadOnlySpan<byte> mem) {
			this = mem.Read<LzhsHeader>(0);
			fixed (byte* dptr = this.spare) {
				if (!new Span<byte>(dptr, 6)
					.ToArray()
					.All(b => b == 0x00)
				) {
					throw new InvalidDataException("Invalid LZHS Header");
				}
			}
		}
	}

	public record HuffmanSymbol(uint code, int length);

	public abstract class HuffmanCacheBase {
		private Dictionary<uint, int> cache = new Dictionary<uint, int>();
		protected abstract uint MakeKey(uint code, int length);

		public void Insert(HuffmanSymbol sym, int idx) {
			var key = MakeKey(sym.code, sym.length);
			cache[key] = idx;
		}

		public bool TryGetValue(HuffmanSymbol sym, out int idx) {
			var key = MakeKey(sym.code, sym.length);
			return cache.TryGetValue(key, out idx);
		}
	}

	public class HuffCharlenCache : HuffmanCacheBase {
		protected override uint MakeKey(uint code, int length) {
			return (uint)(((length & 0xFu) << 13) | (code & 0x1FFFu));
		}
	}

	public class HuffCharposCache : HuffmanCacheBase {
		protected override uint MakeKey(uint code, int length) {
			return (uint)(((length & 0x7u) << 6) | (code & 0x3Fu));
		}
	}

	public record RingBuffer<T>(int size, uint modMask) {
		private List<T> ringBuf = new List<T>();

		public void Fill(T value) {
			ringBuf.Clear();
			ringBuf.AddRange(Enumerable.Repeat(value, size));
		}

		public T this[int idx] {
			get => ringBuf[(int)(idx & modMask)];
			set => ringBuf[(int)(idx & modMask)] = value;
		}
	}

	public record ModCounter(int value, uint modMask) {
		public static ModCounter operator +(ModCounter a, int count) {
			return new ModCounter((int)((a.value + count) & a.modMask), a.modMask);
		}

		public static ModCounter operator -(ModCounter a, int count) => a + (-count);
		public static ModCounter operator ++(ModCounter a) => a + 1;
		public static ModCounter operator --(ModCounter a) => a - 1;
	}

	public enum LzssSequenceType : byte {
		POINTER = 0,
		RAW = 1,
	}

	public class LzhsCache
	{
		public static readonly HuffCharlenCache CharLenCache = new HuffCharlenCache();
		public static readonly HuffCharposCache CharposCache = new HuffCharposCache();
	}

	public class LzhsTables
	{
		public static readonly HuffmanSymbol[] TblCharlen =
			DecodeTable(
				Hex.Decode("020000000500000003000000050000000A00000006000000280000000700000029000000070000002A000000070000002B000000070000002C000000070000002D000000070000002E000000070000002F000000070000008A000000080000008B000000080000008C000000080000008D000000080000008E0000000800000030000000070000008F0000000800000090000000080000008001000009000000910000000800000081010000090000008201000009000000830100000900000031000000070000009200000008000000930000000800000094000000080000000B000000060000008401000009000000850100000900000086010000090000000C00000006000000320000000700000033000000070000009500000008000000960000000800000097000000080000008701000009000000880100000900000034000000070000009800000008000000990000000800000089010000090000009A000000080000009B000000080000008A010000090000008B0100000900000035000000070000009C000000080000009D000000080000008C010000090000008D010000090000008E010000090000008F0100000900000090010000090000009E00000008000000910100000900000092010000090000009301000009000000940100000900000095010000090000009601000009000000970100000900000036000000070000009F000000080000003700000007000000380000000700000098010000090000009901000009000000A0000000080000009A0100000900000039000000070000003A000000070000003B00000007000000A100000008000000A200000008000000A3000000080000009B010000090000009C010000090000009D010000090000009E010000090000009F01000009000000A001000009000000A101000009000000B00300000A000000B10300000A000000B20300000A000000A201000009000000A301000009000000A401000009000000B30300000A000000A501000009000000B40300000A000000B50300000A000000B60300000A0000003C00000007000000A400000008000000A500000008000000A600000008000000A700000008000000A800000008000000A601000009000000B70300000A0000000D00000006000000A900000008000000A701000009000000A801000009000000A901000009000000AA01000009000000AB01000009000000AC010000090000003D00000007000000AD01000009000000AA00000008000000AE01000009000000AF01000009000000B001000009000000B80300000A000000B90300000A0000003E00000007000000B101000009000000B201000009000000B301000009000000BA0300000A000000BB0300000A000000BC0300000A000000BD0300000A0000003F00000007000000AB00000008000000B401000009000000B501000009000000B601000009000000BE0300000A000000BF0300000A000000C00300000A000000AC00000008000000AD00000008000000B701000009000000B801000009000000B901000009000000C10300000A000000C20300000A000000C30300000A000000AE00000008000000AF00000008000000B000000008000000C40300000A000000C50300000A000000C60300000A000000C70300000A000000C80300000A0000004000000007000000B100000008000000BA01000009000000BB01000009000000C90300000A000000CA0300000A000000CB0300000A000000CC0300000A000000B200000008000000B300000008000000CD0300000A000000CE0300000A000000CF0300000A000000D00300000A000000D10300000A000000DE0700000B000000B400000008000000BC01000009000000BD01000009000000BE01000009000000D20300000A000000D30300000A000000DF0700000B000000E00700000B000000B500000008000000D40300000A000000D50300000A000000E10700000B000000D60300000A000000B600000008000000D70300000A000000E20700000B000000D80300000A000000E30700000B000000E40700000B000000E50700000B000000D90300000A000000B700000008000000E60700000B000000E70700000B000000B800000008000000BF01000009000000DA0300000A000000DB0300000A000000DC0300000A000000E80700000B000000E90700000B000000EA0700000B000000C001000009000000C101000009000000DD0300000A000000EB0700000B000000DE0300000A000000EC0700000B000000ED0700000B000000EE0700000B0000000E000000060000000F00000006000000C201000009000000C301000009000000DF0300000A000000C401000009000000EF0700000B000000F00700000B000000C501000009000000C601000009000000E00300000A000000E10300000A000000C701000009000000E20300000A000000F10700000B000000F20700000B0000001000000006000000C801000009000000C901000009000000E30300000A000000E40300000A000000CA01000009000000CB010000090000004100000007000000CC01000009000000CD01000009000000CE01000009000000E50300000A000000E60300000A000000E70300000A000000E80300000A000000E90300000A0000004200000007000000B900000008000000F30700000B000000F40700000B000000EA0300000A000000F50700000B000000CF01000009000000D001000009000000BA00000008000000D101000009000000D201000009000000D301000009000000D401000009000000D501000009000000BB000000080000004300000007000000000000000400000004000000050000001100000006000000120000000600000013000000060000004400000007000000BC00000008000000BD00000008000000BE00000008000000D601000009000000D701000009000000EB0300000A000000EC0300000A000000ED0300000A000000EE0300000A000000F60700000B000000F70700000B000000F80700000B000000F90700000B000000FA0700000B000000FB0700000B000000F80F00000C000000F90F00000C000000FA0F00000C000000FB0F00000C000000FC1F00000D000000FC0F00000C000000FD1F00000D000000FD0F00000C000000FE1F00000D000000FF1F00000D000000BF00000008000000")
			);
		public static readonly HuffmanSymbol[] TblCharpos =
			DecodeTable(
				Hex.Decode("0000000002000000020000000300000006000000040000000E000000050000000F00000005000000100000000500000011000000050000001200000005000000130000000500000014000000050000002A000000060000002B000000060000002C000000060000002D000000060000002E000000060000002F0000000600000030000000060000003100000006000000320000000600000033000000060000003400000006000000350000000600000036000000060000003700000006000000380000000600000039000000060000003A000000060000003B000000060000003C000000060000003D000000060000003E000000060000003F00000006000000")
			);

		private static HuffmanSymbol[] DecodeTable(byte[] data) {
			int numSyms = data.Length / 8;
			HuffmanSymbol[] syms = new HuffmanSymbol[numSyms];

			using (BinaryReader rdr = new BinaryReader(new MemoryStream(data))) {
				for (int i = 0; i < numSyms; i++) {
					uint k = rdr.ReadUInt32();
					int v = rdr.ReadInt32();
					syms[i] = new HuffmanSymbol(k, v);
				}
			}
			return syms;
		}
	}

	public class LzhsDecoder
	{
		public readonly LzhsHeader header;
		private readonly LzhsChecksumPassThru checksum = new LzhsChecksumPassThru();

		private static unsafe LzhsHeader ReadHeader(ReadOnlySpan<byte> data) {
			return data.Slice(0, LzhsHeader.SIZE).ReadStruct<LzhsHeader>();
		}

		private IEnumerable<byte> data;

		public LzhsDecoder(ReadOnlyMemory<byte> data) {
			header = ReadHeader(data.Span);
			this.data = data.ToEnumerable();
		}

		public bool VerifyChecksum() {
			return checksum.Value == header.checksum;
		}

		private uint Pad(uint num, uint align = 16) {
			uint rem = num % align;
			uint pad = rem switch {
				0 => 0,
				_ => 16 - rem
			};
			return num + pad;
		}

		public IEnumerable<byte> AsEnumerable() {
			var huffmanIn = data.Skip(Marshal.SizeOf<LzhsHeader>())
				.Take((int)header.compressedSize);

			var huffmanOut = new HuffmanDecoder(huffmanIn).Decode();
			var lzssOut = new LzssDecoder(huffmanOut).Decode();
			var athumbOut = new ArmThumbConvert(lzssOut).Decode(0);
			var output = athumbOut.Take((int)header.uncompressedSize);
			var final = checksum.Update(output);
			return final;
		}
	}
}
